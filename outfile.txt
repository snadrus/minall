F,hi.txt,12,2025-04-29,a948904f,12,hello world¶F,minall.go,6440,2025-04-29,a8838de9,6453,package main¶¶import (¶→"bufio"¶→"crypto/sha256"¶→"encoding/base64"¶→"flag"¶→"fmt"¶→"io"¶→"os"¶→"path/filepath"¶→"strconv"¶→"strings"¶→"unicode/utf8"¶)¶¶const (¶→NewlineReplacement     = "⌘4:wrY="¶→TabReplacement         = "⌘4:4oaS"¶→UnprintableReplacement = "⌘4:4oyY"¶)¶¶func main() {¶→dirPath := flag.String("dir", "", "Path to the input directory")¶→outputPath := flag.String("out", "", "(Optional) Path to output file. If empty, prints to stdout.")¶→decompress := flag.String("decode", "", "If set, decode from the specified input file instead of encoding")¶→flag.Parse()¶¶→if *decompress != "" {¶→→f, err := os.Open(*decompress)¶→→if err != nil {¶→→→fmt.Fprintf(os.Stderr, "Error opening input file: %v\n", err)¶→→→os.Exit(1)¶→→}¶→→defer f.Close()¶→→if err := decodeArchive(f); err != nil {¶→→→fmt.Fprintf(os.Stderr, "Decoding error: %v\n", err)¶→→→os.Exit(1)¶→→}¶→→return¶→}¶¶→if *dirPath == "" {¶→→fmt.Fprintln(os.Stderr, "Error: input directory path required. Use -dir <directory>")¶→→os.Exit(1)¶→}¶¶→if *outputPath == "" {¶→→fmt.Fprintln(os.Stderr, "Error: output file path required.")¶→→os.Exit(1)¶→}¶¶→f, err := os.Create(*outputPath)¶→if err != nil {¶→→fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)¶→→os.Exit(1)¶→}¶→defer f.Close()¶¶→err = walkAndEncode(*dirPath, f)¶→if err != nil {¶→→fmt.Fprintf(os.Stderr, "Encoding error: %v\n", err)¶→→os.Exit(1)¶→}¶}¶¶func decodeArchive(r io.Reader) error {¶→scanner := bufio.NewScanner(r)¶→scanner.Split(splitComma)¶→for scanner.Scan() {¶→→tok := scanner.Text()¶→→if tok == "" {¶→→→continue¶→→}¶→→switch tok {¶→→case "D":¶→→→if !scanner.Scan() {¶→→→→return fmt.Errorf("expected directory name")¶→→→}¶→→→dir := unescapeCommas(scanner.Text())¶→→→if err := os.MkdirAll(dir, 0755); err != nil {¶→→→→return fmt.Errorf("creating directory %s: %v", dir, err)¶→→→}¶→→case "F":¶→→→if !scanner.Scan() {¶→→→→return fmt.Errorf("expected file name")¶→→→}¶→→→filename := unescapeCommas(scanner.Text())¶→→→if !scanner.Scan() || !scanner.Scan() || !scanner.Scan() {¶→→→→return fmt.Errorf("expected file metadata")¶→→→}¶→→→if !scanner.Scan() {¶→→→→return fmt.Errorf("expected rune length")¶→→→}¶→→→runelen, err := strconv.Atoi(scanner.Text())¶→→→if err != nil {¶→→→→return fmt.Errorf("invalid rune length")¶→→→}¶→→→f, err := os.Create(filename)¶→→→if err != nil {¶→→→→return fmt.Errorf("creating file %s: %v", filename, err)¶→→→}¶→→→defer f.Close()¶→→→dec := bufio.NewWriter(f)¶→→→r := decodeContent(scanner, runelen)¶→→→if _, err := io.Copy(dec, r); err != nil {¶→→→→return fmt.Errorf("writing decoded content: %v", err)¶→→→}¶→→→dec.Flush()¶→→default:¶→→→return fmt.Errorf("unexpected token %q", tok)¶→→}¶→}¶→return scanner.Err()¶}¶¶func decodeContent(scanner *bufio.Scanner, runelen int) io.Reader {¶→pr, pw := io.Pipe()¶→go func() {¶→→defer pw.Close()¶→→count := 0¶→→for scanner.Scan() {¶→→→part := scanner.Text()¶→→→for i := 0; i < len(part); {¶→→→→if part[i] == UnprintableReplacement[0] {¶→→→→→j := i + 1¶→→→→→for j < len(part) && part[j] >= '0' && part[j] <= '9' {¶→→→→→→j++¶→→→→→}¶→→→→→size, _ := strconv.Atoi(part[i+1 : j-1])¶→→→→→data, _ := base64.StdEncoding.DecodeString(part[j-1:][:size])¶→→→→→pw.Write(data)¶→→→→→i = j - 1 + size¶→→→→} else if part[i] == NewlineReplacement[0] {¶→→→→→pw.Write([]byte{'\n'})¶→→→→→i++¶→→→→} else if part[i] == TabReplacement[0] {¶→→→→→pw.Write([]byte{'\t'})¶→→→→→i++¶→→→→} else {¶→→→→→pw.Write([]byte{part[i]})¶→→→→→i++¶→→→→}¶→→→→count++¶→→→→if count >= runelen {¶→→→→→return¶→→→→}¶→→→}¶→→}¶→}()¶→return pr¶}¶¶func splitComma(data []byte, atEOF bool) (advance int, token []byte, err error) {¶→for i := 0; i < len(data); i++ {¶→→if data[i] == ',' {¶→→→return i + 1, data[:i], nil¶→→}¶→}¶→if atEOF && len(data) > 0 {¶→→return len(data), data, nil¶→}¶→return 0, nil, nil¶}¶¶func unescapeCommas(s string) string {¶→return strings.ReplaceAll(s, "\\,", ",")¶}¶¶// //////////////¶func walkAndEncode(root string, w io.Writer) error {¶→return filepath.Walk(root, func(path string, info os.FileInfo, err error) error {¶→→if err != nil {¶→→→return err¶→→}¶→→relPath, _ := filepath.Rel(root, path)¶→→if info.IsDir() {¶→→→if relPath != "." {¶→→→→_, err := fmt.Fprintf(w, "D,%s", escapeCommas(relPath))¶→→→→if err != nil {¶→→→→→return err¶→→→→}¶→→→}¶→→→return nil¶→→}¶¶→→data, err := os.ReadFile(path)¶→→if err != nil {¶→→→return err¶→→}¶¶→→hash := sha256.Sum256(data)¶→→shortHash := fmt.Sprintf("%x", hash[:])[:8]¶→→timestamp := info.ModTime().UTC().Format("2006-01-02")¶→→_, err = fmt.Fprintf(w, "F,%s,%d,%s,%s,", escapeCommas(relPath), len(data), timestamp, shortHash)¶→→if err != nil {¶→→→return err¶→→}¶¶→→// Count runes first¶→→runeCounter := &runeCountingWriter{0}¶→→err = encodeData(data, runeCounter)¶→→if err != nil {¶→→→return err¶→→}¶→→_, err = fmt.Fprintf(w, "%d,", runeCounter.runes)¶→→if err != nil {¶→→→return err¶→→}¶¶→→// Write actual encoded data¶→→err = encodeData(data, w)¶→→if err != nil {¶→→→return err¶→→}¶¶→→return nil¶→})¶}¶¶type runeCountingWriter struct {¶→runes int64¶}¶¶func (rcw *runeCountingWriter) Write(p []byte) (int, error) {¶→for len(p) > 0 {¶→→r, size := utf8.DecodeRune(p)¶→→if r == utf8.RuneError && size == 1 {¶→→→return 0, fmt.Errorf("invalid UTF-8 sequence")¶→→}¶→→rcw.runes++¶→→p = p[size:]¶→}¶→return len(p), nil¶}¶¶func escapeCommas(s string) string {¶→return strings.ReplaceAll(s, ",", "\\,")¶}¶¶func encodeData(data []byte, w io.Writer) error {¶→var unprintable []byte¶→flushUnprintables := func() error {¶→→if len(unprintable) > 0 {¶→→→enc := base64.StdEncoding.EncodeToString(unprintable)¶→→→if _, err := fmt.Fprintf(w, "%s%d:%s", UnprintableReplacement, len(enc), enc); err != nil {¶→→→→return err¶→→→}¶→→→unprintable = unprintable[:0]¶→→}¶→→return nil¶→}¶¶→for _, b := range data {¶→→if b == '\n' {¶→→→if err := flushUnprintables(); err != nil {¶→→→→return err¶→→→}¶→→→_, err := w.Write([]byte(NewlineReplacement))¶→→→if err != nil {¶→→→→return err¶→→→}¶→→} else if b == '\t' {¶→→→if err := flushUnprintables(); err != nil {¶→→→→return err¶→→→}¶→→→_, err := w.Write([]byte(TabReplacement))¶→→→if err != nil {¶→→→→return err¶→→→}¶→→} else if b < 32 || b > 126 {¶→→→unprintable = append(unprintable, b)¶→→} else {¶→→→if err := flushUnprintables(); err != nil {¶→→→→return err¶→→→}¶→→→r, size := utf8.DecodeRune([]byte{b})¶→→→if size > 0 {¶→→→→buf := make([]byte, utf8.RuneLen(r))¶→→→→utf8.EncodeRune(buf, r)¶→→→→_, err := w.Write(buf)¶→→→→if err != nil {¶→→→→→return err¶→→→→}¶→→→}¶→→}¶→}¶→return flushUnprintables()¶}¶