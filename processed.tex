F,hi.txt,12,2025-04-29,a948904f,12,hello world¶F,minall.go,6440,2025-04-29,a8838de9,6453,package main¶¶import (¶\symb{→}"bufio"¶\symb{→}"crypto/sha256"¶\symb{→}"encoding/base64"¶\symb{→}"flag"¶\symb{→}"fmt"¶\symb{→}"io"¶\symb{→}"os"¶\symb{→}"path/filepath"¶\symb{→}"strconv"¶\symb{→}"strings"¶\symb{→}"unicode/utf8"¶)¶¶const (¶\symb{→}NewlineReplacement     = "\symb{⌘}4:wrY="¶\symb{→}TabReplacement         = "\symb{⌘}4:4oaS"¶\symb{→}UnprintableReplacement = "\symb{⌘}4:4oyY"¶)¶¶func main() {¶\symb{→}dirPath := flag.String("dir", "", "Path to the input directory")¶\symb{→}outputPath := flag.String("out", "", "(Optional) Path to output file. If empty, prints to stdout.")¶\symb{→}decompress := flag.String("decode", "", "If set, decode from the specified input file instead of encoding")¶\symb{→}flag.Parse()¶¶\symb{→}if *decompress != "" {¶\symb{→}\symb{→}f, err := os.Open(*decompress)¶\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}fmt.Fprintf(os.Stderr, "Error opening input file: %v\n", err)¶\symb{→}\symb{→}\symb{→}os.Exit(1)¶\symb{→}\symb{→}}¶\symb{→}\symb{→}defer f.Close()¶\symb{→}\symb{→}if err := decodeArchive(f); err != nil {¶\symb{→}\symb{→}\symb{→}fmt.Fprintf(os.Stderr, "Decoding error: %v\n", err)¶\symb{→}\symb{→}\symb{→}os.Exit(1)¶\symb{→}\symb{→}}¶\symb{→}\symb{→}return¶\symb{→}}¶¶\symb{→}if *dirPath == "" {¶\symb{→}\symb{→}fmt.Fprintln(os.Stderr, "Error: input directory path required. Use -dir <directory>")¶\symb{→}\symb{→}os.Exit(1)¶\symb{→}}¶¶\symb{→}if *outputPath == "" {¶\symb{→}\symb{→}fmt.Fprintln(os.Stderr, "Error: output file path required.")¶\symb{→}\symb{→}os.Exit(1)¶\symb{→}}¶¶\symb{→}f, err := os.Create(*outputPath)¶\symb{→}if err != nil {¶\symb{→}\symb{→}fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)¶\symb{→}\symb{→}os.Exit(1)¶\symb{→}}¶\symb{→}defer f.Close()¶¶\symb{→}err = walkAndEncode(*dirPath, f)¶\symb{→}if err != nil {¶\symb{→}\symb{→}fmt.Fprintf(os.Stderr, "Encoding error: %v\n", err)¶\symb{→}\symb{→}os.Exit(1)¶\symb{→}}¶}¶¶func decodeArchive(r io.Reader) error {¶\symb{→}scanner := bufio.NewScanner(r)¶\symb{→}scanner.Split(splitComma)¶\symb{→}for scanner.Scan() {¶\symb{→}\symb{→}tok := scanner.Text()¶\symb{→}\symb{→}if tok == "" {¶\symb{→}\symb{→}\symb{→}continue¶\symb{→}\symb{→}}¶\symb{→}\symb{→}switch tok {¶\symb{→}\symb{→}case "D":¶\symb{→}\symb{→}\symb{→}if !scanner.Scan() {¶\symb{→}\symb{→}\symb{→}\symb{→}return fmt.Errorf("expected directory name")¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}dir := unescapeCommas(scanner.Text())¶\symb{→}\symb{→}\symb{→}if err := os.MkdirAll(dir, 0755); err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}return fmt.Errorf("creating directory %s: %v", dir, err)¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}case "F":¶\symb{→}\symb{→}\symb{→}if !scanner.Scan() {¶\symb{→}\symb{→}\symb{→}\symb{→}return fmt.Errorf("expected file name")¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}filename := unescapeCommas(scanner.Text())¶\symb{→}\symb{→}\symb{→}if !scanner.Scan() || !scanner.Scan() || !scanner.Scan() {¶\symb{→}\symb{→}\symb{→}\symb{→}return fmt.Errorf("expected file metadata")¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}if !scanner.Scan() {¶\symb{→}\symb{→}\symb{→}\symb{→}return fmt.Errorf("expected rune length")¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}runelen, err := strconv.Atoi(scanner.Text())¶\symb{→}\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}return fmt.Errorf("invalid rune length")¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}f, err := os.Create(filename)¶\symb{→}\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}return fmt.Errorf("creating file %s: %v", filename, err)¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}defer f.Close()¶\symb{→}\symb{→}\symb{→}dec := bufio.NewWriter(f)¶\symb{→}\symb{→}\symb{→}r := decodeContent(scanner, runelen)¶\symb{→}\symb{→}\symb{→}if _, err := io.Copy(dec, r); err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}return fmt.Errorf("writing decoded content: %v", err)¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}dec.Flush()¶\symb{→}\symb{→}default:¶\symb{→}\symb{→}\symb{→}return fmt.Errorf("unexpected token %q", tok)¶\symb{→}\symb{→}}¶\symb{→}}¶\symb{→}return scanner.Err()¶}¶¶func decodeContent(scanner *bufio.Scanner, runelen int) io.Reader {¶\symb{→}pr, pw := io.Pipe()¶\symb{→}go func() {¶\symb{→}\symb{→}defer pw.Close()¶\symb{→}\symb{→}count := 0¶\symb{→}\symb{→}for scanner.Scan() {¶\symb{→}\symb{→}\symb{→}part := scanner.Text()¶\symb{→}\symb{→}\symb{→}for i := 0; i < len(part); {¶\symb{→}\symb{→}\symb{→}\symb{→}if part[i] == UnprintableReplacement[0] {¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}j := i + 1¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}for j < len(part) && part[j] >= '0' && part[j] <= '9' {¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}j++¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}size, _ := strconv.Atoi(part[i+1 : j-1])¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}data, _ := base64.StdEncoding.DecodeString(part[j-1:][:size])¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}pw.Write(data)¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}i = j - 1 + size¶\symb{→}\symb{→}\symb{→}\symb{→}} else if part[i] == NewlineReplacement[0] {¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}pw.Write([]byte{'\n'})¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}i++¶\symb{→}\symb{→}\symb{→}\symb{→}} else if part[i] == TabReplacement[0] {¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}pw.Write([]byte{'\t'})¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}i++¶\symb{→}\symb{→}\symb{→}\symb{→}} else {¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}pw.Write([]byte{part[i]})¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}i++¶\symb{→}\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}\symb{→}count++¶\symb{→}\symb{→}\symb{→}\symb{→}if count >= runelen {¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}return¶\symb{→}\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}}¶\symb{→}}()¶\symb{→}return pr¶}¶¶func splitComma(data []byte, atEOF bool) (advance int, token []byte, err error) {¶\symb{→}for i := 0; i < len(data); i++ {¶\symb{→}\symb{→}if data[i] == ',' {¶\symb{→}\symb{→}\symb{→}return i + 1, data[:i], nil¶\symb{→}\symb{→}}¶\symb{→}}¶\symb{→}if atEOF && len(data) > 0 {¶\symb{→}\symb{→}return len(data), data, nil¶\symb{→}}¶\symb{→}return 0, nil, nil¶}¶¶func unescapeCommas(s string) string {¶\symb{→}return strings.ReplaceAll(s, "\\,", ",")¶}¶¶// //////////////¶func walkAndEncode(root string, w io.Writer) error {¶\symb{→}return filepath.Walk(root, func(path string, info os.FileInfo, err error) error {¶\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}}¶\symb{→}\symb{→}relPath, _ := filepath.Rel(root, path)¶\symb{→}\symb{→}if info.IsDir() {¶\symb{→}\symb{→}\symb{→}if relPath != "." {¶\symb{→}\symb{→}\symb{→}\symb{→}_, err := fmt.Fprintf(w, "D,%s", escapeCommas(relPath))¶\symb{→}\symb{→}\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}return nil¶\symb{→}\symb{→}}¶¶\symb{→}\symb{→}data, err := os.ReadFile(path)¶\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}}¶¶\symb{→}\symb{→}hash := sha256.Sum256(data)¶\symb{→}\symb{→}shortHash := fmt.Sprintf("%x", hash[:])[:8]¶\symb{→}\symb{→}timestamp := info.ModTime().UTC().Format("2006-01-02")¶\symb{→}\symb{→}_, err = fmt.Fprintf(w, "F,%s,%d,%s,%s,", escapeCommas(relPath), len(data), timestamp, shortHash)¶\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}}¶¶\symb{→}\symb{→}// Count runes first¶\symb{→}\symb{→}runeCounter := &runeCountingWriter{0}¶\symb{→}\symb{→}err = encodeData(data, runeCounter)¶\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}}¶\symb{→}\symb{→}_, err = fmt.Fprintf(w, "%d,", runeCounter.runes)¶\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}}¶¶\symb{→}\symb{→}// Write actual encoded data¶\symb{→}\symb{→}err = encodeData(data, w)¶\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}}¶¶\symb{→}\symb{→}return nil¶\symb{→}})¶}¶¶type runeCountingWriter struct {¶\symb{→}runes int64¶}¶¶func (rcw *runeCountingWriter) Write(p []byte) (int, error) {¶\symb{→}for len(p) > 0 {¶\symb{→}\symb{→}r, size := utf8.DecodeRune(p)¶\symb{→}\symb{→}if r == utf8.RuneError && size == 1 {¶\symb{→}\symb{→}\symb{→}return 0, fmt.Errorf("invalid UTF-8 sequence")¶\symb{→}\symb{→}}¶\symb{→}\symb{→}rcw.runes++¶\symb{→}\symb{→}p = p[size:]¶\symb{→}}¶\symb{→}return len(p), nil¶}¶¶func escapeCommas(s string) string {¶\symb{→}return strings.ReplaceAll(s, ",", "\\,")¶}¶¶func encodeData(data []byte, w io.Writer) error {¶\symb{→}var unprintable []byte¶\symb{→}flushUnprintables := func() error {¶\symb{→}\symb{→}if len(unprintable) > 0 {¶\symb{→}\symb{→}\symb{→}enc := base64.StdEncoding.EncodeToString(unprintable)¶\symb{→}\symb{→}\symb{→}if _, err := fmt.Fprintf(w, "%s%d:%s", UnprintableReplacement, len(enc), enc); err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}unprintable = unprintable[:0]¶\symb{→}\symb{→}}¶\symb{→}\symb{→}return nil¶\symb{→}}¶¶\symb{→}for _, b := range data {¶\symb{→}\symb{→}if b == '\n' {¶\symb{→}\symb{→}\symb{→}if err := flushUnprintables(); err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}_, err := w.Write([]byte(NewlineReplacement))¶\symb{→}\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}} else if b == '\t' {¶\symb{→}\symb{→}\symb{→}if err := flushUnprintables(); err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}_, err := w.Write([]byte(TabReplacement))¶\symb{→}\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}} else if b < 32 || b > 126 {¶\symb{→}\symb{→}\symb{→}unprintable = append(unprintable, b)¶\symb{→}\symb{→}} else {¶\symb{→}\symb{→}\symb{→}if err := flushUnprintables(); err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}r, size := utf8.DecodeRune([]byte{b})¶\symb{→}\symb{→}\symb{→}if size > 0 {¶\symb{→}\symb{→}\symb{→}\symb{→}buf := make([]byte, utf8.RuneLen(r))¶\symb{→}\symb{→}\symb{→}\symb{→}utf8.EncodeRune(buf, r)¶\symb{→}\symb{→}\symb{→}\symb{→}_, err := w.Write(buf)¶\symb{→}\symb{→}\symb{→}\symb{→}if err != nil {¶\symb{→}\symb{→}\symb{→}\symb{→}\symb{→}return err¶\symb{→}\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}\symb{→}}¶\symb{→}\symb{→}}¶\symb{→}}¶\symb{→}return flushUnprintables()¶}¶